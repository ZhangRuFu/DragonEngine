2017年4月9日23:09:03
-明确Drawer定义
	Drawer包含了Shader，具有Shader才能对某一类物体进行绘制，Drawer是Shader的封装和扩展，提供了方便地绘制接口。某些Drawer实现了Draw虚函数，会在RenderSystem中进行注册来进行绘制，而另一些Drawer仅仅是提供绘制接口，不实现Draw函数，例如Tiny2D，仅仅提供2D绘制接口本身不是针对某一类物体进行绘制，这种Drawer一般会通过被继承来丰富子类的绘制功能
	之前定义的Drawer十分不完善，仅仅代表要被绘制的物体而没有提供其他绘制接口（Tiny2D）的功能，导致画一个Button要写一个shader，画另一个空间要另写一个Shader，非常糟糕

-修改Drawer注册方法
	之前Drawer的注册方法是通过在Drawer的构造函数中调用RenderSystem的注册接口来实现，但是碰到多继承的情况，例如Tiny2D继承了Drawer也继承了FontRender，会注册2次。而且想在注册时使用RTTI也无法正常使用，所以在构造函数中不要使用虚函数，即使是间接
	改为通过每个Drawer子类独有的静态Create方法进行创建，而构造函数为protected，留作继承使用。在Create中进行注册。原先想使用工厂方法模式+可变参数，但是每个具体的Drawer构造时需要不同的参数。

-去除原先单独的UI渲染队列
	现在的渲染队列是十分简单、粗暴的渲染队列，之前给UI单独留一个渲染队列成员。实际上无必要，UI也是渲染对象仅仅是因为要放在最后绘制。改为一视同仁，根据Drawer的GetRenderLevel进行判断，共用一个渲染队列。

-Drawer的多继承
	有时一个绘制对象要借用多个Drawer，不能分开，这样就成为渲染时分开的单元，会造成很多渲染问题。应该看成一个整体，使用多继承，例如Tiny2D，在渲染需要另一个Drawer时进行Shader切换。